// <auto-generated />
//
// To parse this JSON data, add NuGet 'System.Text.Json' then do:
//
//    using Flow.Launcher.Plugin.KomorebiWorkspaceNamer.StateTypes;
//
//    var state = State.FromJson(jsonString);
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
#pragma warning disable CS8618
#pragma warning disable CS8601
#pragma warning disable CS8603

namespace Flow.Launcher.Plugin.KomorebiWorkspaceNamer.StateTypes
{
    using System;
    using System.Collections.Generic;

    using System.Text.Json;
    using System.Text.Json.Serialization;
    using System.Globalization;

    public partial class State
    {
        [JsonPropertyName("monitors")]
        public Monitors Monitors { get; set; }

        [JsonPropertyName("monitor_usr_idx_map")]
        public MonitorUsrIdxMap MonitorUsrIdxMap { get; set; }

        [JsonPropertyName("is_paused")]
        public bool IsPaused { get; set; }

        [JsonPropertyName("resize_delta")]
        public long ResizeDelta { get; set; }

        [JsonPropertyName("new_window_behaviour")]
        public string NewWindowBehaviour { get; set; }

        [JsonPropertyName("float_override")]
        public bool FloatOverride { get; set; }

        [JsonPropertyName("cross_monitor_move_behaviour")]
        public string CrossMonitorMoveBehaviour { get; set; }

        [JsonPropertyName("unmanaged_window_operation_behaviour")]
        public string UnmanagedWindowOperationBehaviour { get; set; }

        [JsonPropertyName("work_area_offset")]
        public object WorkAreaOffset { get; set; }

        [JsonPropertyName("focus_follows_mouse")]
        public object FocusFollowsMouse { get; set; }

        [JsonPropertyName("mouse_follows_focus")]
        public bool MouseFollowsFocus { get; set; }

        [JsonPropertyName("has_pending_raise_op")]
        public bool HasPendingRaiseOp { get; set; }
    }

    public partial class MonitorUsrIdxMap
    {
        [JsonPropertyName("0")]
        public long The0 { get; set; }
    }

    public partial class Monitors
    {
        [JsonPropertyName("elements")]
        public MonitorsElement[] Elements { get; set; }

        [JsonPropertyName("focused")]
        public long Focused { get; set; }
    }

    public partial class MonitorsElement
    {
        [JsonPropertyName("id")]
        public long Id { get; set; }

        [JsonPropertyName("name")]
        public string Name { get; set; }

        [JsonPropertyName("device")]
        public string Device { get; set; }

        [JsonPropertyName("device_id")]
        public string DeviceId { get; set; }

        [JsonPropertyName("serial_number_id")]
        public string SerialNumberId { get; set; }

        [JsonPropertyName("size")]
        public Size Size { get; set; }

        [JsonPropertyName("work_area_size")]
        public Size WorkAreaSize { get; set; }

        [JsonPropertyName("work_area_offset")]
        public Size WorkAreaOffset { get; set; }

        [JsonPropertyName("window_based_work_area_offset")]
        public object WindowBasedWorkAreaOffset { get; set; }

        [JsonPropertyName("window_based_work_area_offset_limit")]
        public long WindowBasedWorkAreaOffsetLimit { get; set; }

        [JsonPropertyName("workspaces")]
        public Workspaces Workspaces { get; set; }

        [JsonPropertyName("last_focused_workspace")]
        public long LastFocusedWorkspace { get; set; }

        [JsonPropertyName("workspace_names")]
        public WorkspaceNames WorkspaceNames { get; set; }

        [JsonPropertyName("container_padding")]
        public object ContainerPadding { get; set; }

        [JsonPropertyName("workspace_padding")]
        public object WorkspacePadding { get; set; }
    }

    public partial class Size
    {
        [JsonPropertyName("left")]
        public long Left { get; set; }

        [JsonPropertyName("top")]
        public long Top { get; set; }

        [JsonPropertyName("right")]
        public long Right { get; set; }

        [JsonPropertyName("bottom")]
        public long Bottom { get; set; }
    }

    public partial class WorkspaceNames
    {
    }

    public partial class Workspaces
    {
        [JsonPropertyName("elements")]
        public WorkspacesElement[] Elements { get; set; }

        [JsonPropertyName("focused")]
        public long Focused { get; set; }
    }

    public partial class WorkspacesElement
    {
        [JsonPropertyName("name")]
        public string Name { get; set; }

        [JsonPropertyName("containers")]
        public Containers Containers { get; set; }

        [JsonPropertyName("monocle_container")]
        public object MonocleContainer { get; set; }

        [JsonPropertyName("maximized_window")]
        public object MaximizedWindow { get; set; }

        [JsonPropertyName("floating_windows")]
        public object[] FloatingWindows { get; set; }

        [JsonPropertyName("layout")]
        public Layout Layout { get; set; }

        [JsonPropertyName("layout_rules")]
        public object[] LayoutRules { get; set; }

        [JsonPropertyName("layout_flip")]
        public object LayoutFlip { get; set; }

        [JsonPropertyName("workspace_padding")]
        public object WorkspacePadding { get; set; }

        [JsonPropertyName("container_padding")]
        public object ContainerPadding { get; set; }

        [JsonPropertyName("latest_layout")]
        public Size[] LatestLayout { get; set; }

        [JsonPropertyName("resize_dimensions")]
        public object[] ResizeDimensions { get; set; }

        [JsonPropertyName("tile")]
        public bool Tile { get; set; }

        [JsonPropertyName("apply_window_based_work_area_offset")]
        public bool ApplyWindowBasedWorkAreaOffset { get; set; }

        [JsonPropertyName("window_container_behaviour")]
        public object WindowContainerBehaviour { get; set; }

        [JsonPropertyName("window_container_behaviour_rules")]
        public object WindowContainerBehaviourRules { get; set; }

        [JsonPropertyName("float_override")]
        public object FloatOverride { get; set; }

        [JsonPropertyName("globals")]
        public Globals Globals { get; set; }

        [JsonPropertyName("layer")]
        public string Layer { get; set; }
    }

    public partial class Containers
    {
        [JsonPropertyName("elements")]
        public ContainersElement[] Elements { get; set; }

        [JsonPropertyName("focused")]
        public long Focused { get; set; }
    }

    public partial class ContainersElement
    {
        [JsonPropertyName("id")]
        public string Id { get; set; }

        [JsonPropertyName("windows")]
        public Windows Windows { get; set; }
    }

    public partial class Windows
    {
        [JsonPropertyName("elements")]
        public WindowsElement[] Elements { get; set; }

        [JsonPropertyName("focused")]
        public long Focused { get; set; }
    }

    public partial class WindowsElement
    {
        [JsonPropertyName("hwnd")]
        public long Hwnd { get; set; }

        [JsonPropertyName("title")]
        public string Title { get; set; }

        [JsonPropertyName("exe")]
        public string Exe { get; set; }

        [JsonPropertyName("class")]
        public string Class { get; set; }

        [JsonPropertyName("rect")]
        public Size Rect { get; set; }
    }

    public partial class Globals
    {
        [JsonPropertyName("container_padding")]
        public long ContainerPadding { get; set; }

        [JsonPropertyName("workspace_padding")]
        public long WorkspacePadding { get; set; }

        [JsonPropertyName("work_area")]
        public Size WorkArea { get; set; }

        [JsonPropertyName("work_area_offset")]
        public Size WorkAreaOffset { get; set; }

        [JsonPropertyName("window_based_work_area_offset")]
        public object WindowBasedWorkAreaOffset { get; set; }

        [JsonPropertyName("window_based_work_area_offset_limit")]
        public long WindowBasedWorkAreaOffsetLimit { get; set; }
    }

    public partial class Layout
    {
        [JsonPropertyName("Default")]
        public string Default { get; set; }
    }

    public partial class State
    {
        public static State FromJson(string json) => JsonSerializer.Deserialize<State>(json, Flow.Launcher.Plugin.KomorebiWorkspaceNamer.StateTypes.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this State self) => JsonSerializer.Serialize(self, Flow.Launcher.Plugin.KomorebiWorkspaceNamer.StateTypes.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerOptions Settings = new(JsonSerializerDefaults.General)
        {
            Converters =
            {
                new DateOnlyConverter(),
                new TimeOnlyConverter(),
                IsoDateTimeOffsetConverter.Singleton
            },
        };
    }
    
    public class DateOnlyConverter : JsonConverter<DateOnly>
    {
        private readonly string serializationFormat;
        public DateOnlyConverter() : this(null) { }

        public DateOnlyConverter(string? serializationFormat)
        {
                this.serializationFormat = serializationFormat ?? "yyyy-MM-dd";
        }

        public override DateOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
                var value = reader.GetString();
                return DateOnly.Parse(value!);
        }

        public override void Write(Utf8JsonWriter writer, DateOnly value, JsonSerializerOptions options)
                => writer.WriteStringValue(value.ToString(serializationFormat));
    }

    public class TimeOnlyConverter : JsonConverter<TimeOnly>
    {
        private readonly string serializationFormat;

        public TimeOnlyConverter() : this(null) { }

        public TimeOnlyConverter(string? serializationFormat)
        {
                this.serializationFormat = serializationFormat ?? "HH:mm:ss.fff";
        }

        public override TimeOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
                var value = reader.GetString();
                return TimeOnly.Parse(value!);
        }

        public override void Write(Utf8JsonWriter writer, TimeOnly value, JsonSerializerOptions options)
                => writer.WriteStringValue(value.ToString(serializationFormat));
    }

    internal class IsoDateTimeOffsetConverter : JsonConverter<DateTimeOffset>
    {
        public override bool CanConvert(Type t) => t == typeof(DateTimeOffset);

        private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

        private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;
        private string? _dateTimeFormat;
        private CultureInfo? _culture;

        public DateTimeStyles DateTimeStyles
        {
                get => _dateTimeStyles;
                set => _dateTimeStyles = value;
        }

        public string? DateTimeFormat
        {
                get => _dateTimeFormat ?? string.Empty;
                set => _dateTimeFormat = (string.IsNullOrEmpty(value)) ? null : value;
        }

        public CultureInfo Culture
        {
                get => _culture ?? CultureInfo.CurrentCulture;
                set => _culture = value;
        }

        public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
        {
                string text;


                if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal
                        || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
                {
                        value = value.ToUniversalTime();
                }

                text = value.ToString(_dateTimeFormat ?? DefaultDateTimeFormat, Culture);

                writer.WriteStringValue(text);
        }

        public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
                string? dateText = reader.GetString();

                if (string.IsNullOrEmpty(dateText) == false)
                {
                        if (!string.IsNullOrEmpty(_dateTimeFormat))
                        {
                                return DateTimeOffset.ParseExact(dateText, _dateTimeFormat, Culture, _dateTimeStyles);
                        }
                        else
                        {
                                return DateTimeOffset.Parse(dateText, Culture, _dateTimeStyles);
                        }
                }
                else
                {
                        return default(DateTimeOffset);
                }
        }


        public static readonly IsoDateTimeOffsetConverter Singleton = new IsoDateTimeOffsetConverter();
    }
}
#pragma warning restore CS8618
#pragma warning restore CS8601
#pragma warning restore CS8603
